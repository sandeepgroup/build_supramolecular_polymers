diff -ruN pyswarms/base/base_single.py pyswarms.new/base/base_single.py
--- pyswarms/base/base_single.py	2023-03-22 20:33:20.208477698 +0530
+++ pyswarms.new/base/base_single.py	2023-03-22 20:34:10.948517815 +0530
@@ -118,6 +118,7 @@
                 "mean_neighbor_cost",
                 "position",
                 "velocity",
+                "best_pos",
             ],
         )
         # Initialize resettable attributes
@@ -131,6 +132,8 @@
         :code:`(iters,)`,on the other hand, the :code:`pos_history`
         and :code:`velocity_history` are expected to have a shape of
         :code:`(iters, n_particles, dimensions)`
+        user added: :code: `pos_history` is expected to have a shape of
+        :code:`(iters, dimensions)`
 
         Parameters
         ----------
@@ -142,6 +145,7 @@
         self.mean_neighbor_history.append(hist.mean_neighbor_cost)
         self.pos_history.append(hist.position)
         self.velocity_history.append(hist.velocity)
+        self.bpos_history.append(hist.best_pos)
 
     @abc.abstractmethod
     def optimize(self, objective_func, iters, n_processes=None, **kwargs):
@@ -199,6 +203,7 @@
         self.mean_neighbor_history = []
         self.pos_history = []
         self.velocity_history = []
+        self.bpos_history = []
 
         # Initialize the swarm
         self.swarm = create_swarm(
diff -ruN pyswarms/single/global_best.py pyswarms.new/single/global_best.py
--- pyswarms/single/global_best.py	2023-03-22 20:33:20.112470167 +0530
+++ pyswarms.new/single/global_best.py	2023-03-22 20:34:10.948517815 +0530
@@ -213,7 +213,7 @@
             self.swarm.best_pos, self.swarm.best_cost = self.top.compute_gbest(self.swarm)
             # fmt: on
             if verbose:
-                self.rep.hook(best_cost=self.swarm.best_cost)
+                self.rep.hook(best_cost=str(self.swarm.best_cost))
             # Save to history
             hist = self.ToHistory(
                 best_cost=self.swarm.best_cost,
@@ -221,13 +221,15 @@
                 mean_neighbor_cost=self.swarm.best_cost,
                 position=self.swarm.position,
                 velocity=self.swarm.velocity,
+                best_pos=self.swarm.best_pos,
             )
+
             self._populate_history(hist)
             # Verify stop criteria based on the relative acceptable cost ftol
             relative_measure = self.ftol * (1 + np.abs(best_cost_yet_found))
             delta = (
                 np.abs(self.swarm.best_cost - best_cost_yet_found)
-                < relative_measure
+                < self.ftol
             )
             if i < self.ftol_iter:
                 ftol_history.append(delta)
diff -ruN pyswarms/single/local_best.py pyswarms.new/single/local_best.py
--- pyswarms/single/local_best.py	2023-03-22 20:33:20.088468285 +0530
+++ pyswarms.new/single/local_best.py	2023-03-22 20:46:14.110460201 +0530
@@ -249,13 +249,14 @@
                 mean_neighbor_cost=np.mean(self.swarm.best_cost),
                 position=self.swarm.position,
                 velocity=self.swarm.velocity,
+                best_pos=self.swarm.best_pos,
             )
             self._populate_history(hist)
             # Verify stop criteria based on the relative acceptable cost ftol
             relative_measure = self.ftol * (1 + np.abs(best_cost_yet_found))
             delta = (
                 np.abs(self.swarm.best_cost - best_cost_yet_found)
-                < relative_measure
+                < self.ftol
             )
             if i < self.ftol_iter:
                 ftol_history.append(delta)
